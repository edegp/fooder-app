/* eslint-disable */
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] }
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> }
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> }
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string
  String: string
  Boolean: boolean
  Int: number
  Float: number
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: any
  /** The builtin Time type */
  Time: any
}

/**
 * CreateRecordInput is used for create Record object.
 * Input was generated by ent.
 */
export type CreateRecordInput = {
  evaluation?: InputMaybe<Scalars['Int']>
  leaveAt?: InputMaybe<Scalars['Int']>
  paymentAmount?: InputMaybe<Scalars['Int']>
  placeID: Scalars['String']
  userID: Scalars['ID']
  visitAt?: InputMaybe<Scalars['Time']>
}

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  age?: InputMaybe<Scalars['Int']>
  createAt?: InputMaybe<Scalars['Time']>
  latestLoginAt?: InputMaybe<Scalars['Time']>
  recordIDs?: InputMaybe<Array<Scalars['ID']>>
}

export type Mutation = {
  __typename?: 'Mutation'
  createRecord?: Maybe<Record>
  createUser?: Maybe<User>
  updateRecord?: Maybe<Record>
  updateUser?: Maybe<User>
}

export type MutationCreateRecordArgs = {
  placeId: Scalars['String']
  userId: Scalars['String']
}

export type MutationCreateUserArgs = {
  age?: InputMaybe<Scalars['String']>
  idToken: Scalars['String']
}

export type MutationUpdateRecordArgs = {
  evaluation?: InputMaybe<Scalars['Int']>
  id: Scalars['String']
  paymentAmount?: InputMaybe<Scalars['Int']>
  placeId?: InputMaybe<Scalars['String']>
  userId?: InputMaybe<Scalars['String']>
}

export type MutationUpdateUserArgs = {
  id: Scalars['String']
}

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']
}

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo'
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>
}

export type Query = {
  __typename?: 'Query'
  getPlaceRecords?: Maybe<Array<Maybe<Record>>>
  getUserParticularPlaceRecords?: Maybe<Array<Maybe<Record>>>
  getUserRecords?: Maybe<Array<Maybe<Record>>>
  /** Fetches an object given its ID. */
  node?: Maybe<Node>
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>
  records: Array<Record>
  users: Array<User>
}

export type QueryGetPlaceRecordsArgs = {
  placeId: Scalars['String']
}

export type QueryGetUserParticularPlaceRecordsArgs = {
  placeId: Scalars['String']
  userId: Scalars['String']
}

export type QueryGetUserRecordsArgs = {
  userId: Scalars['String']
}

export type QueryNodeArgs = {
  id: Scalars['ID']
}

export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>
}

export type Record = Node & {
  __typename?: 'Record'
  evaluation: Scalars['Int']
  id: Scalars['ID']
  leaveAt?: Maybe<Scalars['Int']>
  paymentAmount?: Maybe<Scalars['Int']>
  placeID: Scalars['String']
  user: User
  userID: Scalars['ID']
  visitAt: Scalars['Time']
}

/** Ordering options for Record connections */
export type RecordOrder = {
  /** The ordering direction. */
  direction?: OrderDirection
  /** The field by which to order Records. */
  field: RecordOrderField
}

/** Properties by which Record connections can be ordered. */
export enum RecordOrderField {
  Evaluation = 'EVALUATION',
  PaymentAmount = 'PAYMENT_AMOUNT',
  VisitAt = 'VISIT_AT'
}

/**
 * RecordWhereInput is used for filtering Record objects.
 * Input was generated by ent.
 */
export type RecordWhereInput = {
  and?: InputMaybe<Array<RecordWhereInput>>
  /** evaluation field predicates */
  evaluation?: InputMaybe<Scalars['Int']>
  evaluationGT?: InputMaybe<Scalars['Int']>
  evaluationGTE?: InputMaybe<Scalars['Int']>
  evaluationIn?: InputMaybe<Array<Scalars['Int']>>
  evaluationLT?: InputMaybe<Scalars['Int']>
  evaluationLTE?: InputMaybe<Scalars['Int']>
  evaluationNEQ?: InputMaybe<Scalars['Int']>
  evaluationNotIn?: InputMaybe<Array<Scalars['Int']>>
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']>
  hasUserWith?: InputMaybe<Array<UserWhereInput>>
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>
  idGT?: InputMaybe<Scalars['ID']>
  idGTE?: InputMaybe<Scalars['ID']>
  idIn?: InputMaybe<Array<Scalars['ID']>>
  idLT?: InputMaybe<Scalars['ID']>
  idLTE?: InputMaybe<Scalars['ID']>
  idNEQ?: InputMaybe<Scalars['ID']>
  idNotIn?: InputMaybe<Array<Scalars['ID']>>
  /** leave_at field predicates */
  leaveAt?: InputMaybe<Scalars['Int']>
  leaveAtGT?: InputMaybe<Scalars['Int']>
  leaveAtGTE?: InputMaybe<Scalars['Int']>
  leaveAtIn?: InputMaybe<Array<Scalars['Int']>>
  leaveAtIsNil?: InputMaybe<Scalars['Boolean']>
  leaveAtLT?: InputMaybe<Scalars['Int']>
  leaveAtLTE?: InputMaybe<Scalars['Int']>
  leaveAtNEQ?: InputMaybe<Scalars['Int']>
  leaveAtNotIn?: InputMaybe<Array<Scalars['Int']>>
  leaveAtNotNil?: InputMaybe<Scalars['Boolean']>
  not?: InputMaybe<RecordWhereInput>
  or?: InputMaybe<Array<RecordWhereInput>>
  /** payment_amount field predicates */
  paymentAmount?: InputMaybe<Scalars['Int']>
  paymentAmountGT?: InputMaybe<Scalars['Int']>
  paymentAmountGTE?: InputMaybe<Scalars['Int']>
  paymentAmountIn?: InputMaybe<Array<Scalars['Int']>>
  paymentAmountIsNil?: InputMaybe<Scalars['Boolean']>
  paymentAmountLT?: InputMaybe<Scalars['Int']>
  paymentAmountLTE?: InputMaybe<Scalars['Int']>
  paymentAmountNEQ?: InputMaybe<Scalars['Int']>
  paymentAmountNotIn?: InputMaybe<Array<Scalars['Int']>>
  paymentAmountNotNil?: InputMaybe<Scalars['Boolean']>
  /** place_id field predicates */
  placeID?: InputMaybe<Scalars['String']>
  placeIDContains?: InputMaybe<Scalars['String']>
  placeIDContainsFold?: InputMaybe<Scalars['String']>
  placeIDEqualFold?: InputMaybe<Scalars['String']>
  placeIDGT?: InputMaybe<Scalars['String']>
  placeIDGTE?: InputMaybe<Scalars['String']>
  placeIDHasPrefix?: InputMaybe<Scalars['String']>
  placeIDHasSuffix?: InputMaybe<Scalars['String']>
  placeIDIn?: InputMaybe<Array<Scalars['String']>>
  placeIDLT?: InputMaybe<Scalars['String']>
  placeIDLTE?: InputMaybe<Scalars['String']>
  placeIDNEQ?: InputMaybe<Scalars['String']>
  placeIDNotIn?: InputMaybe<Array<Scalars['String']>>
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['ID']>
  userIDContains?: InputMaybe<Scalars['ID']>
  userIDContainsFold?: InputMaybe<Scalars['ID']>
  userIDEqualFold?: InputMaybe<Scalars['ID']>
  userIDGT?: InputMaybe<Scalars['ID']>
  userIDGTE?: InputMaybe<Scalars['ID']>
  userIDHasPrefix?: InputMaybe<Scalars['ID']>
  userIDHasSuffix?: InputMaybe<Scalars['ID']>
  userIDIn?: InputMaybe<Array<Scalars['ID']>>
  userIDLT?: InputMaybe<Scalars['ID']>
  userIDLTE?: InputMaybe<Scalars['ID']>
  userIDNEQ?: InputMaybe<Scalars['ID']>
  userIDNotIn?: InputMaybe<Array<Scalars['ID']>>
  /** visit_at field predicates */
  visitAt?: InputMaybe<Scalars['Time']>
  visitAtGT?: InputMaybe<Scalars['Time']>
  visitAtGTE?: InputMaybe<Scalars['Time']>
  visitAtIn?: InputMaybe<Array<Scalars['Time']>>
  visitAtLT?: InputMaybe<Scalars['Time']>
  visitAtLTE?: InputMaybe<Scalars['Time']>
  visitAtNEQ?: InputMaybe<Scalars['Time']>
  visitAtNotIn?: InputMaybe<Array<Scalars['Time']>>
}

/**
 * UpdateRecordInput is used for update Record object.
 * Input was generated by ent.
 */
export type UpdateRecordInput = {
  clearLeaveAt?: InputMaybe<Scalars['Boolean']>
  clearPaymentAmount?: InputMaybe<Scalars['Boolean']>
  clearUser?: InputMaybe<Scalars['Boolean']>
  evaluation?: InputMaybe<Scalars['Int']>
  leaveAt?: InputMaybe<Scalars['Int']>
  paymentAmount?: InputMaybe<Scalars['Int']>
  placeID?: InputMaybe<Scalars['String']>
  userID?: InputMaybe<Scalars['ID']>
  visitAt?: InputMaybe<Scalars['Time']>
}

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addRecordIDs?: InputMaybe<Array<Scalars['ID']>>
  age?: InputMaybe<Scalars['Int']>
  clearAge?: InputMaybe<Scalars['Boolean']>
  clearRecord?: InputMaybe<Scalars['Boolean']>
  latestLoginAt?: InputMaybe<Scalars['Time']>
  removeRecordIDs?: InputMaybe<Array<Scalars['ID']>>
}

export type User = Node & {
  __typename?: 'User'
  age?: Maybe<Scalars['Int']>
  createAt: Scalars['Time']
  id: Scalars['ID']
  latestLoginAt: Scalars['Time']
  record?: Maybe<Array<Record>>
}

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection
  /** The field by which to order Users. */
  field: UserOrderField
}

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  Age = 'AGE',
  CreatedAt = 'CREATED_AT',
  LatestLoginAt = 'LATEST_LOGIN_AT'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  /** age field predicates */
  age?: InputMaybe<Scalars['Int']>
  ageGT?: InputMaybe<Scalars['Int']>
  ageGTE?: InputMaybe<Scalars['Int']>
  ageIn?: InputMaybe<Array<Scalars['Int']>>
  ageIsNil?: InputMaybe<Scalars['Boolean']>
  ageLT?: InputMaybe<Scalars['Int']>
  ageLTE?: InputMaybe<Scalars['Int']>
  ageNEQ?: InputMaybe<Scalars['Int']>
  ageNotIn?: InputMaybe<Array<Scalars['Int']>>
  ageNotNil?: InputMaybe<Scalars['Boolean']>
  and?: InputMaybe<Array<UserWhereInput>>
  /** create_at field predicates */
  createAt?: InputMaybe<Scalars['Time']>
  createAtGT?: InputMaybe<Scalars['Time']>
  createAtGTE?: InputMaybe<Scalars['Time']>
  createAtIn?: InputMaybe<Array<Scalars['Time']>>
  createAtLT?: InputMaybe<Scalars['Time']>
  createAtLTE?: InputMaybe<Scalars['Time']>
  createAtNEQ?: InputMaybe<Scalars['Time']>
  createAtNotIn?: InputMaybe<Array<Scalars['Time']>>
  /** record edge predicates */
  hasRecord?: InputMaybe<Scalars['Boolean']>
  hasRecordWith?: InputMaybe<Array<RecordWhereInput>>
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>
  idGT?: InputMaybe<Scalars['ID']>
  idGTE?: InputMaybe<Scalars['ID']>
  idIn?: InputMaybe<Array<Scalars['ID']>>
  idLT?: InputMaybe<Scalars['ID']>
  idLTE?: InputMaybe<Scalars['ID']>
  idNEQ?: InputMaybe<Scalars['ID']>
  idNotIn?: InputMaybe<Array<Scalars['ID']>>
  /** latest_login_at field predicates */
  latestLoginAt?: InputMaybe<Scalars['Time']>
  latestLoginAtGT?: InputMaybe<Scalars['Time']>
  latestLoginAtGTE?: InputMaybe<Scalars['Time']>
  latestLoginAtIn?: InputMaybe<Array<Scalars['Time']>>
  latestLoginAtLT?: InputMaybe<Scalars['Time']>
  latestLoginAtLTE?: InputMaybe<Scalars['Time']>
  latestLoginAtNEQ?: InputMaybe<Scalars['Time']>
  latestLoginAtNotIn?: InputMaybe<Array<Scalars['Time']>>
  not?: InputMaybe<UserWhereInput>
  or?: InputMaybe<Array<UserWhereInput>>
}
